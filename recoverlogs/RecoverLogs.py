# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RecoverLogs
                                 A QGIS plugin
 This plugin displays logs of specified features
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-05-21
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QDate, Qt
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QErrorMessage, QTableWidgetItem, QHeaderView, QTableWidget

from qgis.core import *
from qgis.utils import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .RecoverLogs_dialog import *
from .dbConfiguration import DbConfig
import os.path
from datetime import datetime, date
import numpy as np
import requests
import json

class RecoverLogs:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'RecoverLogs_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = RecoverLogsDialog()
        self.dlg1 = ConfigDialog()
        self.dlg2 = ResultsDialog()
        self.dlg3 = DetailsDialog()
        self.dlg4 = DetailsDialog1()
        self.dlg5 = ResultsDialog1()
        # self.dlg6 = ResultsDialog1Filt()
        # self.dlg7 = ResultsDialogFilt()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&TPL Logs Plugin')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'RecoverLogs')
        self.toolbar.setObjectName(u'RecoverLogs')

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('RecoverLogs', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def showConfig(self):
        self.dlg1.show()
        self.dlg1.exec_()

    def updateDlg(self):
        self.DbName = self.dlg1.dbLineEdit.text()
        self.password = self.dlg1.passLineEdit.text()
        self.host = self.dlg1.ipLineEdit.text()
        self.port = self.dlg1.portLineEdit.text()
        self.user = self.dlg1.userLineEdit.text()
        self.conn = DbConfig(self.host, self.DbName, self.port, self.user, self.password)
        self.ElasticSearchIP = self.dlg1.eIPLineEdit.text()
        self.ElasticSearchPort = self.dlg1.ePortLineEdit.text()
        try:
            rqstIndex = requests.get('http://{0}:{1}/_cat/indices?v'.format(self.ElasticSearchIP, self.ElasticSearchPort))
            tableNames = [a for a in rqstIndex.text.split(" ") if "users_log" in a]
            # tableNames = [tableName[0] for tableName in tableNames]
            self.dlg.tableComboBox.clear()
            self.dlg.tableComboBox.addItems(tableNames)
            self.dlg.searchBtn.setEnabled(True)
            self.dlg.IdRadBtn.setEnabled(True)
            self.dlg.lineEdit.setEnabled(True)
            self.dlg.UserRadBtn.setEnabled(True)
            self.dlg1.close()
        except AttributeError:
            err = QErrorMessage(self.dlg1)
            err.showMessage("Invalid DB credentials")
            self.dlg.searchBtn.setEnabled(False)
            self.dlg.label_2.setEnabled(False)
            self.dlg.lineEdit.setEnabled(False)
            self.dlg.label_6.setEnabled(False)
            self.dlg.lineEdit_2.setEnabled(False)

    def setDateRange(self):
        maxDatepayload = {
            "aggs": {
                "max_date": {"max": {"field": "log_date"}}
            }
        }
        rqstMaxDate = requests.post('http://{0}:{1}/{2}/_search?size=0'
                                    .format(self.ElasticSearchIP, self.ElasticSearchPort,
                                            self.dlg.tableComboBox.currentText()),
                                    json=maxDatepayload)
        maxDate = rqstMaxDate.json()["aggregations"]["max_date"]["value_as_string"][0:10]
        maxDateList = maxDate.split("-")

        minDatepayload = {
            "aggs": {
                "min_date": {"min": {"field": "log_date"}}
            }
        }
        rqstMinDate = requests.post('http://{0}:{1}/{2}/_search?size=0'
                                    .format(self.ElasticSearchIP, self.ElasticSearchPort,
                                            self.dlg.tableComboBox.currentText())
                                    , json=minDatepayload)
        minDate = rqstMinDate.json()["aggregations"]["min_date"]["value_as_string"][0:10]
        minDateList = minDate.split("-")

        self.dlg.startDateEdit.setDateRange(QDate(int(minDateList[0]), int(minDateList[1]), int(minDateList[2])),
                                            QDate(int(maxDateList[0]), int(maxDateList[1]), int(maxDateList[2])))
        self.dlg.endDateEdit.setDateRange(QDate(int(minDateList[0]), int(minDateList[1]), int(minDateList[2])),
                                          QDate(int(maxDateList[0]), int(maxDateList[1]), int(maxDateList[2])))

        self.dlg.startDateEdit.setDate(QDate(int(minDateList[0]), int(minDateList[1]), int(minDateList[2])))
        self.dlg.endDateEdit.setDate(QDate(int(maxDateList[0]), int(maxDateList[1]), int(maxDateList[2])))

    def isValidDate(self):
        if self.dlg.startDateEdit.date() > self.dlg.endDateEdit.date():
            self.dlg.searchBtn.setEnabled(False)
        else:
            self.dlg.searchBtn.setEnabled(True)

    def clearVars(self):
        self.logRecords = None
        self.insertCol = None
        self.deleteCol = None
        self.updateColsNewList = None
        self.updateColsOldList = None
        self.idxs = []

    def logSearch(self):
        self.clearVars()
        self.dlg2.tableWidget.setRowCount(0)
        self.dlg5.tableWidget.setRowCount(0)
        sDate = str(self.dlg.startDateEdit.date().toPyDate())
        eDate = str(self.dlg.endDateEdit.date().toPyDate())
        logTable = self.dlg.tableComboBox.currentText()
        # QgsMessageLog.logMessage(eDate)
        # self.conn.ConnectDb()
        if self.dlg.IdRadBtn.isChecked() and len(self.dlg.lineEdit.text()) > 4 and self.dlg.lineEdit.text().isdigit():
            IdBasedPayload = {
                "size": 10000,
                "query": {
                    "bool": {
                        "filter": {
                            "bool": {
                                "must": [{"match": {"feature_id": int(float(self.dlg.lineEdit.text()))}},
                                         {"range": {
                                             "log_date": {
                                                 "gte": "{}".format(sDate),
                                                 "lte": "{}".format(eDate),
                                                 "format": "yyyy-MM-dd"}
                                         }}],
                                "should": [
                                    {"wildcard": {"tbname": "*pois*"}},
                                    {"wildcard": {"tbname": "*road*"}},
                                    {"wildcard": {"tbname": "*scale*"}},
                                    {"wildcard": {"tbname": "*house*"}},
                                    {"wildcard": {"tbname": "*carto*"}}
                                ]
                            }}
                    }
                },
                "_source": ["tbname", "username", "operation", "operation_time", "feature_id", "new_record", "old_record", "log_id"]
            }
            logReqst = requests.post('http://{0}:{1}/{2}/_search'
                                     .format(self.ElasticSearchIP, self.ElasticSearchPort,
                                             self.dlg.tableComboBox.currentText()),
                                     json=IdBasedPayload)
            self.logRecords = [hit["_source"] for hit in logReqst.json()["hits"]["hits"]]
        elif self.dlg.UserRadBtn.isChecked() and len(self.dlg.lineEdit_2.text()) > 5 and len(self.dlg.lineEdit_2.text().split(".")) > 1:
            UserBasedPayload = {
                "size": 10000,
                "query": {
                    "bool": {
                        "filter": {
                            "bool": {
                                "must": [{"match": {"username": "\"{}\"".format(self.dlg.lineEdit_2.text())}},
                                         {"range": {
                                             "log_date": {
                                                 "gte": "{}".format(sDate),
                                                 "lte": "{}".format(eDate),
                                                 "format": "yyyy-MM-dd"}
                                         }}],
                                "should": [
                                    {"wildcard": {"tbname": "*pois*"}},
                                    {"wildcard": {"tbname": "*road*"}},
                                    {"wildcard": {"tbname": "*scale*"}},
                                    {"wildcard": {"tbname": "*house*"}},
                                    {"wildcard": {"tbname": "*carto*"}}
                                ]
                            }}
                    }
                },
                "_source": ["tbname", "username", "operation", "operation_time", "feature_id", "new_record", "old_record", "log_id"]}
            logReqst = requests.post('http://{0}:{1}/{2}/_search'
                                     .format(self.ElasticSearchIP, self.ElasticSearchPort,
                                             self.dlg.tableComboBox.currentText()),
                                     json=UserBasedPayload)
            self.logRecords = [hit["_source"] for hit in logReqst.json()["hits"]["hits"]]

        else:
            self.logRecords=[]
            err = QErrorMessage(self.dlg)
            err.showMessage("Invalid Value!")
        self.showResults()
        # self.conn.releaseDbConnection()
    def showResults(self):
        if len(self.logRecords) > 0:
            self.dlg.progressBar.setValue(0)
            self.insertCol = []
            self.deleteCol = []
            self.updateColsNewList = []
            self.updateColsOldList = []
            self.idxs = []
            self.dlg2.tableWidget.setRowCount(0)
            self.dlg5.tableWidget.setRowCount(0)
            idx = 0
            for i, val in enumerate(self.logRecords):
                progress = (float(i+1) / float(len(self.logRecords))) * 100
                self.dlg.progressBar.setValue(progress)
                usr = val["username"]
                table = val["tbname"]
                operation = val["operation"]
                op_time = val["operation_time"]
                featId = val["feature_id"]
                logId = val["log_id"]
                recordList = [usr, operation, op_time]
                # conn1 = DbConfig('172.16.130.23', 'TPLMaps', '5432', self.user, self.password)
                conn1 = self.conn
                name = 'NULL'
                if 'pois' in table:
                    keys = ['address', 'telephone', 'name', 'name_displ', 'tpl_subcat', 'priority', 'geom', 'poi_status', 'data_status', 'email', 'tpl_cat']
                    if len(self.dlg.lineEdit.text()) > 0:
                        conn1.ConnectDb()
                        name = conn1.DbResultsQuery("""select name_displ from pois_v6 where id={0}"""
                                                    .format(self.dlg.lineEdit.text()))
                        try:
                            name = name[0][0]
                        except IndexError:
                            name = "None"
                        conn1.releaseDbConnection()
                elif 'road' in table:
                    keys = ['priority', 'name', 'dir', 'mode', 'grade_f', 'grade_t', 'tpl_usage', 'restricted', 'geom']
                    if len(self.dlg.lineEdit.text()) > 0:
                        conn1.ConnectDb()
                        name = conn1.DbResultsQuery("""select name from pak_roads_v5 where id={0}"""
                                                    .format(self.dlg.lineEdit.text()))
                        try:
                            name = name[0][0]
                        except IndexError:
                            name = "None"
                        conn1.releaseDbConnection()
                elif 'house' in table:
                    keys = ['name', 'geom']
                    if len(self.dlg.lineEdit.text()) > 0:
                        conn1.ConnectDb()
                        name = conn1.DbResultsQuery("""select name from house where id={0}"""
                                                    .format(self.dlg.lineEdit.text()))
                        try:
                            name = name[0][0]
                        except IndexError:
                            name = "None"
                        conn1.releaseDbConnection()
                elif 'cartographic' in table:
                    keys = ['name', 'kind', 'geom', 'name_displ', 'restricted']
                    if len(self.dlg.lineEdit.text()) > 0:
                        conn1.ConnectDb()
                        name = conn1.DbResultsQuery("""select name_displ from cartographic_v3 where id={0}"""
                                                    .format(self.dlg.lineEdit.text()))
                        try:
                            name = name[0][0]
                        except IndexError:
                            name = "None"
                        conn1.releaseDbConnection()
                elif 'scale' in table:
                    keys = ['kind', 'priority', 'name_displ', 'geom']
                    if len(self.dlg.lineEdit.text()) > 0:
                        conn1.ConnectDb()
                        name = conn1.DbResultsQuery("""select name_displ from scale_polygons_v4 where id={0}"""
                                                    .format(self.dlg.lineEdit.text()))
                        try:
                            name = name[0][0]
                        except IndexError:
                            name = "None"
                        conn1.releaseDbConnection()

                updateColsNew = {}
                updateColsOld = {}

                if operation == 'UPDATE':
                    for key in keys:
                        if val["new_record"][key] != val["old_record"][key]:
                            updateColsNew[key] = val["new_record"][key]
                            updateColsOld[key] = val["old_record"][key]
                    self.updateColsNewList.append([updateColsNew, logId])
                    self.updateColsOldList.append([updateColsOld, logId])

                elif operation == 'INSERT':
                    self.insertCol.append([logId, val["new_record"]])
                elif operation == 'DELETE':
                    self.deleteCol.append([logId, val["old_record"]])

                if len(self.dlg.lineEdit.text()) > 4:
                    self.dlg2.tableWidget.setSortingEnabled(True)
                    self.dlg2.tableWidget.setEditTriggers(QTableWidget.NoEditTriggers)
                    header = self.dlg2.tableWidget.horizontalHeader()
                    header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
                    header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
                    header.setSectionResizeMode(2, QHeaderView.ResizeToContents)
                    header.setSectionResizeMode(3, QHeaderView.ResizeToContents)
                    header.setSectionResizeMode(4, QHeaderView.ResizeToContents)

                    if operation == 'UPDATE' and len(list(updateColsNew.keys())) > 0:
                        self.dlg2.tableWidget.insertRow(idx)
                        self.dlg2.tableWidget.setItem(idx, 0, QTableWidgetItem(str(recordList[0])))
                        self.dlg2.tableWidget.setItem(idx, 1, QTableWidgetItem(str(recordList[1])))
                        self.dlg2.tableWidget.setItem(idx, 2, QTableWidgetItem(str(recordList[2])))
                        self.dlg2.tableWidget.setItem(idx, 3, QTableWidgetItem(",".join(list(updateColsNew.keys()))))
                        self.dlg2.tableWidget.setItem(idx, 4, QTableWidgetItem(str(logId)))
                        idx += 1
                        self.idxs.append(i)
                    elif operation == 'INSERT' or operation == 'DELETE':
                        self.dlg2.tableWidget.insertRow(idx)
                        self.dlg2.tableWidget.setItem(idx, 0, QTableWidgetItem(str(recordList[0])))
                        self.dlg2.tableWidget.setItem(idx, 1, QTableWidgetItem(str(recordList[1])))
                        self.dlg2.tableWidget.setItem(idx, 2, QTableWidgetItem(str(recordList[2])))
                        self.dlg2.tableWidget.setItem(idx, 3, QTableWidgetItem("Feature:{}".format(operation)))
                        self.dlg2.tableWidget.setItem(idx, 4, QTableWidgetItem(str(logId)))
                        idx += 1
                        self.idxs.append(i)
                else:
                    self.dlg5.tableWidget.setSortingEnabled(True)
                    self.dlg5.tableWidget.setEditTriggers(QTableWidget.NoEditTriggers)
                    header = self.dlg5.tableWidget.horizontalHeader()
                    header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
                    header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
                    header.setSectionResizeMode(2, QHeaderView.ResizeToContents)
                    header.setSectionResizeMode(3, QHeaderView.ResizeToContents)
                    header.setSectionResizeMode(4, QHeaderView.ResizeToContents)
                    header.setSectionResizeMode(5, QHeaderView.ResizeToContents)

                    if operation == 'UPDATE' and len(list(updateColsNew.keys())) > 0:
                        self.dlg5.tableWidget.insertRow(idx)
                        self.dlg5.tableWidget.setItem(idx, 0, QTableWidgetItem(str(featId)))
                        self.dlg5.tableWidget.setItem(idx, 1, QTableWidgetItem(str(table)))
                        self.dlg5.tableWidget.setItem(idx, 2, QTableWidgetItem(str(recordList[1])))
                        self.dlg5.tableWidget.setItem(idx, 3, QTableWidgetItem(str(recordList[2])))
                        self.dlg5.tableWidget.setItem(idx, 4, QTableWidgetItem(",".join(list(updateColsNew.keys()))))
                        self.dlg5.tableWidget.setItem(idx, 5, QTableWidgetItem(str(logId)))
                        idx += 1
                        self.idxs.append(i)
                    elif operation == 'INSERT' or operation == 'DELETE':
                        self.dlg5.tableWidget.insertRow(idx)
                        self.dlg5.tableWidget.setItem(idx, 0, QTableWidgetItem(str(featId)))
                        self.dlg5.tableWidget.setItem(idx, 1, QTableWidgetItem(str(table)))
                        self.dlg5.tableWidget.setItem(idx, 2, QTableWidgetItem(str(recordList[1])))
                        self.dlg5.tableWidget.setItem(idx, 3, QTableWidgetItem(str(recordList[2])))
                        self.dlg5.tableWidget.setItem(idx, 4, QTableWidgetItem("Feature:{}".format(operation)))
                        self.dlg5.tableWidget.setItem(idx, 5, QTableWidgetItem(str(logId)))
                        idx += 1
                        self.idxs.append(i)

            if len(self.dlg.lineEdit.text()) > 4:
                self.dlg2.label.clear()
                self.dlg2.label.setText("ID:{0}     Name:{1}    Table:{2}"
                                        .format(self.dlg.lineEdit.text(), name, table))
                self.dlg2.tableWidget.move(0, 0)
                self.dlg2.show()
                self.dlg2.exec_()
            else:
                self.dlg5.label.clear()
                self.dlg5.label.setText("User:{0}".format(self.dlg.lineEdit_2.text()))
                self.dlg5.tableWidget.move(0, 0)
                self.dlg5.show()
                self.dlg5.exec_()
        else:
            err = QErrorMessage(self.dlg)
            err.showMessage("No record Found")

    def clearProgress(self):
        self.dlg.progressBar.setValue(0)

    def filterResults(self):
        # self.dlg5.tableWidget.setRowCount(0)
        self.dlg5.clearBtn.setEnabled(True)
        if len(self.dlg5.filtIdlineEdit.text()) > 4 and len(self.dlg5.filtOplineEdit.text()) == 0 and\
                len(self.dlg5.filtCollineEdit.text()) == 0:
            log_id = []
            for srchItm in self.dlg5.tableWidget.findItems(self.dlg5.filtIdlineEdit.text(), Qt.MatchExactly):
                if self.dlg5.tableWidget.column(srchItm) == 0:
                    log_id.append(self.dlg5.tableWidget.item(self.dlg5.tableWidget.row(srchItm), 5).text())
        elif len(self.dlg5.filtIdlineEdit.text()) == 0 and len(self.dlg5.filtOplineEdit.text()) >= 6 and\
                len(self.dlg5.filtCollineEdit.text()) == 0:
            log_id = []
            for srchItm in self.dlg5.tableWidget.findItems(self.dlg5.filtOplineEdit.text(), Qt.MatchContains):
                if self.dlg5.tableWidget.column(srchItm) == 2:
                    log_id.append(self.dlg5.tableWidget.item(self.dlg5.tableWidget.row(srchItm), 5).text())
        elif len(self.dlg5.filtIdlineEdit.text()) == 0 and len(self.dlg5.filtOplineEdit.text()) == 0 and\
                len(self.dlg5.filtCollineEdit.text()) >= 4:
            log_id = []
            for srchItm in self.dlg5.tableWidget.findItems(self.dlg5.filtCollineEdit.text(), Qt.MatchContains):
                if self.dlg5.tableWidget.column(srchItm) == 4:
                    log_id.append(self.dlg5.tableWidget.item(self.dlg5.tableWidget.row(srchItm), 5).text())
        elif len(self.dlg5.filtIdlineEdit.text()) > 4 and len(self.dlg5.filtOplineEdit.text()) >= 6 and\
                len(self.dlg5.filtCollineEdit.text()) == 0:
            log_id = []
            for srchItm in self.dlg5.tableWidget.findItems(self.dlg5.filtIdlineEdit.text(), Qt.MatchExactly):
                if self.dlg5.tableWidget.column(srchItm) == 0:
                    txt = self.dlg5.tableWidget.item(self.dlg5.tableWidget.row(srchItm), 2).text()
                    if txt == self.dlg5.filtOplineEdit.text().upper():
                        log_id.append(self.dlg5.tableWidget.item(self.dlg5.tableWidget.row(srchItm), 5).text())
        elif len(self.dlg5.filtIdlineEdit.text()) > 4 and len(self.dlg5.filtOplineEdit.text()) == 0 and\
                len(self.dlg5.filtCollineEdit.text()) >= 4:
            log_id = []
            for srchItm in self.dlg5.tableWidget.findItems(self.dlg5.filtIdlineEdit.text(), Qt.MatchExactly):
                if self.dlg5.tableWidget.column(srchItm) == 0:
                    txt = self.dlg5.tableWidget.item(self.dlg5.tableWidget.row(srchItm), 4).text()
                    if self.dlg5.filtCollineEdit.text().lower() in txt.lower():
                        log_id.append(self.dlg5.tableWidget.item(self.dlg5.tableWidget.row(srchItm), 5).text())
        elif len(self.dlg5.filtIdlineEdit.text()) == 0 and len(self.dlg5.filtOplineEdit.text()) >= 6 and\
                len(self.dlg5.filtCollineEdit.text()) >= 4:
            log_id = []
            for srchItm in self.dlg5.tableWidget.findItems(self.dlg5.filtOplineEdit.text(), Qt.MatchContains):
                if self.dlg5.tableWidget.column(srchItm) == 2:
                    txt = self.dlg5.tableWidget.item(self.dlg5.tableWidget.row(srchItm), 4).text()
                    if self.dlg5.filtCollineEdit.text().lower() in txt.lower():
                        log_id.append(self.dlg5.tableWidget.item(self.dlg5.tableWidget.row(srchItm), 5).text())
        elif len(self.dlg5.filtIdlineEdit.text()) > 4 and len(self.dlg5.filtOplineEdit.text()) >= 6 and\
                len(self.dlg5.filtCollineEdit.text()) >= 4:
            log_id = []
            for srchItm in self.dlg5.tableWidget.findItems(self.dlg5.filtIdlineEdit.text(), Qt.MatchExactly):
                if self.dlg5.tableWidget.column(srchItm) == 0:
                    txt = self.dlg5.tableWidget.item(self.dlg5.tableWidget.row(srchItm), 4).text()
                    if self.dlg5.filtCollineEdit.text().lower() in txt.lower():
                        txt1 = self.dlg5.tableWidget.item(self.dlg5.tableWidget.row(srchItm), 2).text()
                        if self.dlg5.filtOplineEdit.text().upper() in txt1:
                            log_id.append(self.dlg5.tableWidget.item(self.dlg5.tableWidget.row(srchItm), 5).text())
        idx = 0
        for i in range(self.dlg5.tableWidget.rowCount()):
            if self.dlg5.tableWidget.item(i - idx, 5).text() not in log_id:
                self.dlg5.tableWidget.removeRow(i - idx)
                idx += 1

    def filterResults1(self):
        # self.dlg5.tableWidget.setRowCount(0)
        self.dlg2.clearBtn.setEnabled(True)
        self.dlg2.cl
        if len(self.dlg2.filtIdlineEdit.text()) > 4 and len(self.dlg2.filtOplineEdit.text()) == 0 and\
                len(self.dlg2.filtCollineEdit.text()) == 0:
            log_id = []
            for srchItm in self.dlg2.tableWidget.findItems(self.dlg2.filtIdlineEdit.text(), Qt.MatchContains):
                if self.dlg2.tableWidget.column(srchItm) == 0:
                    log_id.append(self.dlg2.tableWidget.item(self.dlg2.tableWidget.row(srchItm), 4).text())
        elif len(self.dlg2.filtIdlineEdit.text()) == 0 and len(self.dlg2.filtOplineEdit.text()) >= 6 and\
                len(self.dlg2.filtCollineEdit.text()) == 0:
            log_id = []
            for srchItm in self.dlg2.tableWidget.findItems(self.dlg2.filtOplineEdit.text(), Qt.MatchContains):
                if self.dlg2.tableWidget.column(srchItm) == 1:
                    log_id.append(self.dlg2.tableWidget.item(self.dlg2.tableWidget.row(srchItm), 4).text())
        elif len(self.dlg2.filtIdlineEdit.text()) == 0 and len(self.dlg2.filtOplineEdit.text()) == 0 and\
                len(self.dlg2.filtCollineEdit.text()) >= 4:
            log_id = []
            for srchItm in self.dlg2.tableWidget.findItems(self.dlg2.filtCollineEdit.text(), Qt.MatchContains):
                if self.dlg2.tableWidget.column(srchItm) == 3:
                    log_id.append(self.dlg2.tableWidget.item(self.dlg2.tableWidget.row(srchItm), 4).text())
        elif len(self.dlg2.filtIdlineEdit.text()) > 4 and len(self.dlg2.filtOplineEdit.text()) >= 6 and\
                len(self.dlg2.filtCollineEdit.text()) == 0:
            log_id = []
            for srchItm in self.dlg2.tableWidget.findItems(self.dlg2.filtIdlineEdit.text(), Qt.MatchContains):
                if self.dlg2.tableWidget.column(srchItm) == 0:
                    txt = self.dlg2.tableWidget.item(self.dlg2.tableWidget.row(srchItm), 1).text()
                    if txt == self.dlg2.filtOplineEdit.text().upper():
                        log_id.append(self.dlg2.tableWidget.item(self.dlg2.tableWidget.row(srchItm), 4).text())
        elif len(self.dlg2.filtIdlineEdit.text()) > 4 and len(self.dlg2.filtOplineEdit.text()) == 0 and\
                len(self.dlg2.filtCollineEdit.text()) >= 4:
            log_id = []
            for srchItm in self.dlg2.tableWidget.findItems(self.dlg2.filtIdlineEdit.text(), Qt.MatchContains):
                if self.dlg2.tableWidget.column(srchItm) == 0:
                    txt = self.dlg2.tableWidget.item(self.dlg2.tableWidget.row(srchItm), 3).text()
                    if self.dlg2.filtCollineEdit.text().lower() in txt.lower():
                        log_id.append(self.dlg2.tableWidget.item(self.dlg2.tableWidget.row(srchItm), 4).text())
        elif len(self.dlg2.filtIdlineEdit.text()) == 0 and len(self.dlg2.filtOplineEdit.text()) >= 6 and\
                len(self.dlg2.filtCollineEdit.text()) >= 4:
            log_id = []
            for srchItm in self.dlg2.tableWidget.findItems(self.dlg2.filtOplineEdit.text(), Qt.MatchContains):
                if self.dlg2.tableWidget.column(srchItm) == 1:
                    txt = self.dlg2.tableWidget.item(self.dlg2.tableWidget.row(srchItm), 3).text()
                    if self.dlg2.filtCollineEdit.text().lower() in txt.lower():
                        log_id.append(self.dlg2.tableWidget.item(self.dlg2.tableWidget.row(srchItm), 4).text())
        elif len(self.dlg2.filtIdlineEdit.text()) > 4 and len(self.dlg2.filtOplineEdit.text()) >= 6 and\
                len(self.dlg2.filtCollineEdit.text()) >= 4:
            log_id = []
            for srchItm in self.dlg2.tableWidget.findItems(self.dlg2.filtIdlineEdit.text(), Qt.MatchContains):
                if self.dlg2.tableWidget.column(srchItm) == 0:
                    txt = self.dlg2.tableWidget.item(self.dlg2.tableWidget.row(srchItm), 3).text()
                    if self.dlg2.filtCollineEdit.text().lower() in txt.lower():
                        txt1 = self.dlg2.tableWidget.item(self.dlg2.tableWidget.row(srchItm), 1).text()
                        if self.dlg2.filtOplineEdit.text().upper() in txt1:
                            log_id.append(self.dlg2.tableWidget.item(self.dlg2.tableWidget.row(srchItm), 4).text())
        idx = 0
        for i in range(self.dlg2.tableWidget.rowCount()):
            if self.dlg2.tableWidget.item(i-idx, 4).text() not in log_id:
                self.dlg2.tableWidget.removeRow(i-idx)
                idx += 1

    def showDetails(self):
        self.dlg3.tableWidget.setRowCount(0)
        itm = self.dlg2.tableWidget.currentItem()
        ide = self.dlg2.tableWidget.indexFromItem(itm)
        id = int(self.dlg2.tableWidget.item(ide.row(), 4).text())

        reqItm = self.dlg2.tableWidget.item(ide.row(), 3)
        # QgsMessageLog.logMessage(str(reqItm.text()))
        if len(reqItm.text().split(':')) == 1:
            count = 0
            self.dlg3.tableWidget.setSortingEnabled(True)
            self.dlg3.tableWidget.setEditTriggers(QTableWidget.NoEditTriggers)
            header = self.dlg3.tableWidget.horizontalHeader()
            header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
            header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
            header.setSectionResizeMode(2, QHeaderView.ResizeToContents)
            for idx, val in enumerate(self.updateColsNewList):
                if val[1] == id:
                    for txt in reqItm.text().split(","):
                        self.dlg3.tableWidget.insertRow(count)
                        self.dlg3.tableWidget.setItem(count, 0, QTableWidgetItem(txt))
                        itmTxtValNew = val[0][txt]
                        self.dlg3.tableWidget.setItem(count, 2, QTableWidgetItem(str(itmTxtValNew)))
                        itmTxtValOld = self.updateColsOldList[idx][0][txt]
                        self.dlg3.tableWidget.setItem(count, 1, QTableWidgetItem(str(itmTxtValOld)))
                        count += 1
            self.dlg3.show()
            self.dlg3.exec_()
        elif len(reqItm.text().split(':')) > 1 and reqItm.text().split(':')[1] == 'INSERT':
            self.dlg4.tableWidget.setRowCount(0)
            self.dlg4.tableWidget.setSortingEnabled(True)
            self.dlg4.tableWidget.setEditTriggers(QTableWidget.NoEditTriggers)
            header = self.dlg4.tableWidget.horizontalHeader()
            header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
            header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
            for insrtCol in self.insertCol:
                if insrtCol[0] == id:
                    for ii, col in enumerate(list(insrtCol[1].keys())):
                        self.dlg4.tableWidget.insertRow(ii)
                        self.dlg4.tableWidget.setItem(ii, 0, QTableWidgetItem(col))
                        self.dlg4.tableWidget.setItem(ii, 1, QTableWidgetItem(str(insrtCol[1][col])))
            self.dlg4.show()
            self.dlg4.exec_()
        elif len(reqItm.text().split(':')) > 1 and reqItm.text().split(':')[1] == 'DELETE':
            self.dlg4.tableWidget.setRowCount(0)
            self.dlg4.tableWidget.setSortingEnabled(True)
            self.dlg4.tableWidget.setEditTriggers(QTableWidget.NoEditTriggers)
            header = self.dlg4.tableWidget.horizontalHeader()
            header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
            header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
            for deleteCol in self.deleteCol:
                if deleteCol[0] == id:
                    for ii, col in enumerate(list(deleteCol[1].keys())):
                        self.dlg4.tableWidget.insertRow(ii)
                        self.dlg4.tableWidget.setItem(ii, 0, QTableWidgetItem(col))
                        self.dlg4.tableWidget.setItem(ii, 1, QTableWidgetItem(str(self.insrtCol[1][col])))
            self.dlg4.show()
            self.dlg4.exec_()

    def showDetails1(self):
        self.dlg3.tableWidget.setRowCount(0)
        itm = self.dlg5.tableWidget.currentItem()
        ide = self.dlg5.tableWidget.indexFromItem(itm)
        id = int(self.dlg5.tableWidget.item(ide.row(), 5).text())
        # print(id)
        reqItm = self.dlg5.tableWidget.item(ide.row(), 4)
        # QgsMessageLog.logMessage(str(reqItm.text()))
        if len(reqItm.text().split(':')) == 1:
            count = 0
            self.dlg3.tableWidget.setSortingEnabled(True)
            self.dlg3.tableWidget.setEditTriggers(QTableWidget.NoEditTriggers)
            header = self.dlg3.tableWidget.horizontalHeader()
            header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
            header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
            header.setSectionResizeMode(2, QHeaderView.ResizeToContents)
            for idx, val in enumerate(self.updateColsNewList):
                if val[1] == id:
                    for txt in reqItm.text().split(","):
                        self.dlg3.tableWidget.insertRow(count)
                        self.dlg3.tableWidget.setItem(count, 0, QTableWidgetItem(txt))
                        itmTxtValNew = val[0][txt]
                        self.dlg3.tableWidget.setItem(count, 2, QTableWidgetItem(str(itmTxtValNew)))
                        itmTxtValOld = self.updateColsOldList[idx][0][txt]
                        self.dlg3.tableWidget.setItem(count, 1, QTableWidgetItem(str(itmTxtValOld)))
                        count += 1
            self.dlg3.show()
            self.dlg3.exec_()
        elif len(reqItm.text().split(':')) > 1 and reqItm.text().split(':')[1] == 'INSERT':
            self.dlg4.tableWidget.setRowCount(0)
            self.dlg4.tableWidget.setSortingEnabled(True)
            self.dlg4.tableWidget.setEditTriggers(QTableWidget.NoEditTriggers)
            header = self.dlg4.tableWidget.horizontalHeader()
            header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
            header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
            for insrtCol in self.insertCol:
                if insrtCol[0] == id:
                    for ii, col in enumerate(list(insrtCol[1].keys())):
                        self.dlg4.tableWidget.insertRow(ii)
                        self.dlg4.tableWidget.setItem(ii, 0, QTableWidgetItem(col))
                        self.dlg4.tableWidget.setItem(ii, 1, QTableWidgetItem(str(insrtCol[1][col])))
            self.dlg4.show()
            self.dlg4.exec_()
        elif len(reqItm.text().split(':')) > 1 and reqItm.text().split(':')[1] == 'DELETE':
            self.dlg4.tableWidget.setRowCount(0)
            self.dlg4.tableWidget.setSortingEnabled(True)
            self.dlg4.tableWidget.setEditTriggers(QTableWidget.NoEditTriggers)
            header = self.dlg4.tableWidget.horizontalHeader()
            header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
            header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
            for deleteCol in self.deleteCol:
                if deleteCol[0] == id:
                    for ii, col in enumerate(list(deleteCol[1].keys())):
                        self.dlg4.tableWidget.insertRow(ii)
                        self.dlg4.tableWidget.setItem(ii, 0, QTableWidgetItem(col))
                        self.dlg4.tableWidget.setItem(ii, 1, QTableWidgetItem(str(deleteCol[1][col])))
            self.dlg4.show()
            self.dlg4.exec_()

    def update(self):
        self.clearProgress()
        self.setDateRange()

    def stateChange(self):
        self.update()
        self.dlg.lineEdit.clear()
        self.dlg.lineEdit_2.clear()
        if self.dlg.IdRadBtn.isChecked():
            self.dlg.lineEdit.setEnabled(True)
            self.dlg.lineEdit_2.setEnabled(False)
        else:
            self.dlg.lineEdit.setEnabled(False)
            self.dlg.lineEdit_2.setEnabled(True)
    def clearFilt(self):
        self.dlg2.filtOplineEdit.clear()
        self.dlg2.filtIdlineEdit.clear()
        self.dlg2.filtCollineEdit.clear()
        self.dlg2.clearBtn.setEnabled(False)
        self.showResults()

    def clearFilt1(self): 
        self.dlg5.filtOplineEdit.clear()
        self.dlg5.filtIdlineEdit.clear()
        self.dlg5.filtCollineEdit.clear()
        self.dlg5.clearBtn.setEnabled(False)
        self.showResults()

    def makeConnections(self):
        self.dlg.configBtn.clicked.connect(self.showConfig)
        self.dlg1.okButton.clicked.connect(self.updateDlg)
        self.dlg.searchBtn.clicked.connect(self.logSearch)
        self.dlg.tableComboBox.currentTextChanged.connect(self.update)
        self.dlg.lineEdit.textChanged.connect(self.clearProgress)
        self.dlg.lineEdit_2.textChanged.connect(self.clearProgress)
        self.dlg.startDateEdit.dateChanged.connect(self.clearProgress)
        self.dlg.endDateEdit.dateChanged.connect(self.clearProgress)
        self.dlg2.tableWidget.itemDoubleClicked.connect(self.showDetails)
        self.dlg5.tableWidget.itemDoubleClicked.connect(self.showDetails1)
        self.dlg.startDateEdit.dateChanged.connect(self.isValidDate)
        self.dlg.endDateEdit.dateChanged.connect(self.isValidDate)
        self.dlg.IdRadBtn.clicked.connect(self.stateChange)
        self.dlg.UserRadBtn.clicked.connect(self.stateChange)
        self.dlg5.FilterBtn.clicked.connect(self.filterResults)
        self.dlg5.clearBtn.clicked.connect(self.clearFilt1)
        self.dlg2.FilterBtn.clicked.connect(self.filterResults1)
        self.dlg2.clearBtn.clicked.connect(self.clearFilt)

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        self.makeConnections()
        icon_path = ':/plugins/RecoverLogs/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'DisplayLogs'),
            callback=self.run,
            parent=self.iface.mainWindow())

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&TPL Logs Plugin'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar


    def run(self):
        """Run method that performs all the real work"""
        # show the dialog
        self.dlg.show()
        self.dlg.progressBar.setValue(0)
        self.dlg2.tableWidget.setRowCount(0)
        self.dlg3.tableWidget.setRowCount(0)
        self.dlg4.tableWidget.setRowCount(0)
        self.dlg5.tableWidget.setRowCount(0)
        # Run the dialog event loop
        self.dlg.exec_()
